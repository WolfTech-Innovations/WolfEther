package main
import("crypto/rand";"crypto/sha256";"crypto/aes";"crypto/cipher";"encoding/hex";"encoding/json";"fmt";"log";"math/big";"net";"net/http";"strconv";"strings";"sync";"time";"github.com/btcsuite/btcd/btcutil/hdkeychain";"github.com/btcsuite/btcd/chaincfg";"github.com/ethereum/go-ethereum/common";"github.com/ethereum/go-ethereum/crypto";"github.com/tyler-smith/go-bip39";"golang.org/x/net/proxy")
const(MainNetID=468;TestNetID=469;BlockReward=50;PoWDiff=4;PoSStake=1000;BlockTime=15;CoinCreateCost=10000;TorPort=9050;MainPort=8545;TestPort=8546;P2PMainPort=30303;P2PTestPort=30304)
type Block struct{H BlockHeader`json:"h"`;Txs[]*Tx`json:"t"`;Hash[]byte`json:"hash"`;Nonce uint64`json:"n"`;Miner common.Address`json:"m"`;Sig[]byte`json:"sig"`}
type BlockHeader struct{PH[]byte`json:"ph"`;MR[]byte`json:"mr"`;TS uint64`json:"ts"`;Height uint64`json:"h"`;Diff uint32`json:"d"`;NetID uint32`json:"nid"`}
type Tx struct{From,To common.Address`json:"f,t"`;Value*big.Int`json:"v"`;Nonce uint64`json:"n"`;Sig[]byte`json:"s"`;Type string`json:"type"`;Token common.Address`json:"token"`;Data[]byte`json:"data"`}
type Account struct{Addr common.Address`json:"a"`;Bal,Stake*big.Int`json:"b,s"`;Nonce uint64`json:"n"`;StakeAt time.Time`json:"sa"`;Tokens map[common.Address]*big.Int`json:"tokens"`}
type Token struct{Addr common.Address`json:"a"`;Name,Symbol string`json:"n,s"`;Supply,MaxSupply*big.Int`json:"supply,max"`;Owner common.Address`json:"owner"`;Mintable bool`json:"mint"`}
type Wallet struct{Addr common.Address`json:"a"`;Priv string`json:"p"`;Mnemonic string`json:"m"`;Path string`json:"path"`;EncKey[]byte`json:"key"`}
type Validator struct{Addr common.Address`json:"a"`;Stake,Rewards*big.Int`json:"s,r"`;Active bool`json:"active"`;RepScore uint32`json:"rep"`}
type LNChannel struct{ID string`json:"id"`;Peer1,Peer2 common.Address`json:"p1,p2"`;Balance1,Balance2*big.Int`json:"b1,b2"`;Open bool`json:"open"`;Encrypted bool`json:"enc"`}
type P2PNode struct{ID string`json:"id"`;OnionAddr string`json:"onion"`;LastSeen time.Time`json:"ls"`;Height,NetID uint64`json:"h,nid"`;Rep uint32`json:"rep"`}
type Blockchain struct{Chain[]*Block`json:"c"`;Accounts map[common.Address]*Account`json:"a"`;TxPool[]*Tx`json:"tp"`;Validators map[common.Address]*Validator`json:"v"`;Channels map[string]*LNChannel`json:"ch"`;Nodes map[string]*P2PNode`json:"n"`;Tokens map[common.Address]*Token`json:"tokens"`;mu sync.RWMutex;nodeID,onionAddr string;netID uint32;torDialer proxy.Dialer}
type RPC struct{bc*Blockchain}
func NewBlockchain(netID uint32)*Blockchain{bc:=&Blockchain{Accounts:make(map[common.Address]*Account),TxPool:[]*Tx{},Validators:make(map[common.Address]*Validator),Channels:make(map[string]*LNChannel),Nodes:make(map[string]*P2PNode),Tokens:make(map[common.Address]*Token),nodeID:genNodeID(),netID:netID};bc.setupTor();bc.createGenesis();return bc}
func genNodeID()string{b:=make([]byte,32);rand.Read(b);return hex.EncodeToString(b)}
func(bc*Blockchain)setupTor(){dialer,err:=proxy.SOCKS5("tcp","127.0.0.1:"+strconv.Itoa(TorPort),nil,proxy.Direct);if err!=nil{log.Printf("Tor not available, using clearnet: %v",err);return};bc.torDialer=dialer;bc.onionAddr=bc.generateOnionAddr()}
func(bc*Blockchain)generateOnionAddr()string{hash:=sha256.Sum256([]byte(bc.nodeID));return hex.EncodeToString(hash[:16])+".onion"}
func(bc*Blockchain)createGenesis(){admin:=common.HexToAddress("0x0001");supply,_:=new(big.Int).SetString("1000000000000000000000000",10);bc.Accounts[admin]=&Account{Addr:admin,Bal:supply,Stake:big.NewInt(0),Tokens:make(map[common.Address]*big.Int)};genesis:=&Block{H:BlockHeader{PH:[]byte{},TS:uint64(time.Now().Unix()),Height:0,Diff:PoWDiff,NetID:bc.netID},Txs:[]*Tx{}};genesis.Hash=bc.calcHash(genesis);bc.signBlock(genesis,admin);bc.Chain=append(bc.Chain,genesis)}
func(bc*Blockchain)calcHash(b*Block)[]byte{data:=fmt.Sprintf("%x%d%d%d%d%d",b.H.PH,b.H.TS,b.H.Height,b.Nonce,b.H.NetID,len(b.Txs));for _,tx:=range b.Txs{data+=fmt.Sprintf("%s%s%s",tx.From.Hex(),tx.To.Hex(),tx.Value.String())};h:=sha256.Sum256([]byte(data));return h[:]}
func(bc*Blockchain)signBlock(b*Block,minerAddr common.Address){hash:=bc.calcHash(b);privKey,_:=crypto.GenerateKey();sig,_:=crypto.Sign(hash,privKey);b.Sig=sig}
func(bc*Blockchain)verifyBlock(b*Block)bool{if len(b.Sig)==0{return false};hash:=bc.calcHash(b);pubKey,err:=crypto.SigToPub(hash,b.Sig);return err==nil&&pubKey!=nil}
func(bc*Blockchain)minePoW(b*Block){target:=big.NewInt(1);target.Lsh(target,uint(256-PoWDiff));for{hash:=bc.calcHash(b);hashInt:=big.NewInt(0);hashInt.SetBytes(hash);if hashInt.Cmp(target)==-1{b.Hash=hash;break};b.Nonce++}}
func(bc*Blockchain)selectPoSValidator()common.Address{validators:=[]common.Address{};totalStake:=big.NewInt(0);for addr,val:=range bc.Validators{if val.Active&&val.Stake.Cmp(big.NewInt(PoSStake))>=0&&val.RepScore>50{validators=append(validators,addr);totalStake.Add(totalStake,val.Stake)}};if len(validators)==0{return common.Address{}};seed:=time.Now().UnixNano();return validators[seed%int64(len(validators))]}
func(bc*Blockchain)AddBlock(){bc.mu.Lock();defer bc.mu.Unlock();if len(bc.TxPool)==0{return};last:=bc.Chain[len(bc.Chain)-1];new:=&Block{H:BlockHeader{PH:last.Hash,TS:uint64(time.Now().Unix()),Height:last.H.Height+1,Diff:PoWDiff,NetID:bc.netID},Txs:bc.TxPool[:min(len(bc.TxPool),100)]};if new.H.Height%2==0{bc.minePoW(new);new.Miner=common.HexToAddress("0x0001")}else{validator:=bc.selectPoSValidator();if validator!=(common.Address{}){new.Hash=bc.calcHash(new);new.Miner=validator}};bc.signBlock(new,new.Miner);if bc.verifyBlock(new){bc.Chain=append(bc.Chain,new);bc.TxPool=bc.TxPool[len(new.Txs):];bc.processRewards(new);bc.processTxs(new.Txs);bc.broadcastBlock(new)}}
func(bc*Blockchain)processRewards(b*Block){reward:=big.NewInt(BlockReward);if miner,ok:=bc.Accounts[b.Miner];ok{miner.Bal.Add(miner.Bal,reward);if val,exists:=bc.Validators[b.Miner];exists{val.RepScore++;val.Rewards.Add(val.Rewards,reward)}};for addr,val:=range bc.Validators{if val.Active{sr:=new(big.Int).Mul(val.Stake,big.NewInt(5));sr.Div(sr,big.NewInt(10000));val.Rewards.Add(val.Rewards,sr);bc.Accounts[addr].Bal.Add(bc.Accounts[addr].Bal,sr)}}}
func(bc*Blockchain)processTxs(txs[]*Tx){for _,tx:=range txs{bc.ProcessTx(tx)}}
func(bc*Blockchain)AddTx(tx*Tx)error{bc.mu.Lock();defer bc.mu.Unlock();if!bc.validateTx(tx){return fmt.Errorf("invalid tx")};bc.TxPool=append(bc.TxPool,tx);bc.broadcastTx(tx);return nil}
func(bc*Blockchain)validateTx(tx*Tx)bool{sender,ok:=bc.Accounts[tx.From];if!ok{return false};if tx.Token==(common.Address{}){if sender.Bal.Cmp(tx.Value)<0{return false}}else{if tokenBal,exists:=sender.Tokens[tx.Token];!exists||tokenBal.Cmp(tx.Value)<0{return false}};if tx.Nonce!=sender.Nonce+1{return false};hash:=bc.txHash(tx);pubKey,err:=crypto.SigToPub(hash,tx.Sig);return err==nil&&crypto.PubkeyToAddress(*pubKey)==tx.From}
func(bc*Blockchain)txHash(tx*Tx)[]byte{data:=fmt.Sprintf("%s%s%s%d%s%s",tx.From.Hex(),tx.To.Hex(),tx.Value.String(),tx.Nonce,tx.Type,tx.Token.Hex());if len(tx.Data)>0{data+=hex.EncodeToString(tx.Data)};h:=sha256.Sum256([]byte(data));return h[:]}
func(bc*Blockchain)ProcessTx(tx*Tx){sender:=bc.Accounts[tx.From];receiver:=bc.Accounts[tx.To];if receiver==nil{receiver=&Account{Addr:tx.To,Bal:big.NewInt(0),Stake:big.NewInt(0),Tokens:make(map[common.Address]*big.Int)};bc.Accounts[tx.To]=receiver};if tx.Type=="token_create"{bc.createToken(tx)}else if tx.Token==(common.Address{}){sender.Bal.Sub(sender.Bal,tx.Value);receiver.Bal.Add(receiver.Bal,tx.Value)}else{sender.Tokens[tx.Token].Sub(sender.Tokens[tx.Token],tx.Value);if receiver.Tokens[tx.Token]==nil{receiver.Tokens[tx.Token]=big.NewInt(0)};receiver.Tokens[tx.Token].Add(receiver.Tokens[tx.Token],tx.Value)};sender.Nonce++}
func(bc*Blockchain)createToken(tx*Tx)error{if tx.Value.Cmp(big.NewInt(CoinCreateCost))<0{return fmt.Errorf("insufficient payment for token creation")};var tokenData struct{Name,Symbol string;MaxSupply string;Mintable bool};if err:=json.Unmarshal(tx.Data,&tokenData);err!=nil{return err};supply,_:=new(big.Int).SetString(tokenData.MaxSupply,10);tokenAddr:=crypto.CreateAddress(tx.From,tx.Nonce);bc.Tokens[tokenAddr]=&Token{Addr:tokenAddr,Name:tokenData.Name,Symbol:tokenData.Symbol,Supply:supply,MaxSupply:supply,Owner:tx.From,Mintable:tokenData.Mintable};if bc.Accounts[tx.From].Tokens==nil{bc.Accounts[tx.From].Tokens=make(map[common.Address]*big.Int)};bc.Accounts[tx.From].Tokens[tokenAddr]=supply;return nil}
func(bc*Blockchain)Stake(addr common.Address,amt*big.Int)error{bc.mu.Lock();defer bc.mu.Unlock();acc,ok:=bc.Accounts[addr];if!ok||acc.Bal.Cmp(amt)<0{return fmt.Errorf("insufficient balance")};acc.Bal.Sub(acc.Bal,amt);acc.Stake.Add(acc.Stake,amt);if val,ok:=bc.Validators[addr];ok{val.Stake.Add(val.Stake,amt)}else{bc.Validators[addr]=&Validator{Addr:addr,Stake:new(big.Int).Set(amt),Active:true,Rewards:big.NewInt(0),RepScore:100}};return nil}
func generateMnemonic()string{entropy,_:=bip39.NewEntropy(256);mnemonic,_:=bip39.NewMnemonic(entropy);return mnemonic}
func createWalletFromMnemonic(mnemonic string)*Wallet{seed:=bip39.NewSeed(mnemonic,"");masterKey,_:=hdkeychain.NewMaster(seed,&chaincfg.MainNetParams);childKey,_:=masterKey.Derive(hdkeychain.HardenedKeyStart+44);childKey,_=childKey.Derive(hdkeychain.HardenedKeyStart+60);childKey,_=childKey.Derive(hdkeychain.HardenedKeyStart+0);childKey,_=childKey.Derive(0);childKey,_=childKey.Derive(0);privKey,_:=childKey.ECPrivKey();ethPriv:=crypto.ToECDSAUnsafe(privKey.Serialize());addr:=crypto.PubkeyToAddress(ethPriv.PublicKey);encKey:=make([]byte,32);rand.Read(encKey);return&Wallet{Addr:addr,Priv:hex.EncodeToString(crypto.FromECDSA(ethPriv)),Mnemonic:mnemonic,Path:"m/44'/60'/0'/0/0",EncKey:encKey}}
func(w*Wallet)encrypt(data string)string{block,_:=aes.NewCipher(w.EncKey);gcm,_:=cipher.NewGCM(block);nonce:=make([]byte,gcm.NonceSize());rand.Read(nonce);encrypted:=gcm.Seal(nonce,nonce,[]byte(data),nil);return hex.EncodeToString(encrypted)}
func(w*Wallet)decrypt(encData string)string{data,_:=hex.DecodeString(encData);block,_:=aes.NewCipher(w.EncKey);gcm,_:=cipher.NewGCM(block);nonceSize:=gcm.NonceSize();nonce,ciphertext:=data[:nonceSize],data[nonceSize:];decrypted,_:=gcm.Open(nil,nonce,ciphertext,nil);return string(decrypted)}
func(bc*Blockchain)OpenLNChannel(peer1,peer2 common.Address,amt1,amt2*big.Int)string{bc.mu.Lock();defer bc.mu.Unlock();id:=fmt.Sprintf("%s-%s-%d",peer1.Hex(),peer2.Hex(),time.Now().UnixNano());bc.Channels[id]=&LNChannel{ID:id,Peer1:peer1,Peer2:peer2,Balance1:amt1,Balance2:amt2,Open:true,Encrypted:true};bc.Accounts[peer1].Bal.Sub(bc.Accounts[peer1].Bal,amt1);bc.Accounts[peer2].Bal.Sub(bc.Accounts[peer2].Bal,amt2);return id}
func(bc*Blockchain)LNTransfer(channelID string,from common.Address,amt*big.Int)error{bc.mu.Lock();defer bc.mu.Unlock();ch,ok:=bc.Channels[channelID];if!ok||!ch.Open{return fmt.Errorf("channel not found")};if ch.Peer1==from{if ch.Balance1.Cmp(amt)<0{return fmt.Errorf("insufficient balance")};ch.Balance1.Sub(ch.Balance1,amt);ch.Balance2.Add(ch.Balance2,amt)}else{if ch.Balance2.Cmp(amt)<0{return fmt.Errorf("insufficient balance")};ch.Balance2.Sub(ch.Balance2,amt);ch.Balance1.Add(ch.Balance1,amt)};return nil}
func(bc*Blockchain)CloseLNChannel(channelID string){bc.mu.Lock();defer bc.mu.Unlock();ch,ok:=bc.Channels[channelID];if!ok{return};bc.Accounts[ch.Peer1].Bal.Add(bc.Accounts[ch.Peer1].Bal,ch.Balance1);bc.Accounts[ch.Peer2].Bal.Add(bc.Accounts[ch.Peer2].Bal,ch.Balance2);delete(bc.Channels,channelID)}
func(bc*Blockchain)discoverNodes(){port:=P2PMainPort;if bc.netID==TestNetID{port=P2PTestPort};for{conn,err:=net.ListenUDP("udp",&net.UDPAddr{Port:port});if err!=nil{time.Sleep(5*time.Second);continue};for{buf:=make([]byte,2048);n,_,_:=conn.ReadFromUDP(buf);if n>0{var node P2PNode;if json.Unmarshal(buf[:n],&node)==nil&&node.NetID==uint64(bc.netID){bc.mu.Lock();bc.Nodes[node.ID]=&P2PNode{ID:node.ID,OnionAddr:node.OnionAddr,LastSeen:time.Now(),Height:node.Height,NetID:node.NetID,Rep:node.Rep};bc.mu.Unlock()}}};conn.Close()}}
func(bc*Blockchain)broadcastNode(){port:=P2PMainPort;if bc.netID==TestNetID{port=P2PTestPort};for{bc.mu.RLock();nodeInfo:=P2PNode{ID:bc.nodeID,OnionAddr:bc.onionAddr,Height:uint64(len(bc.Chain)),NetID:uint64(bc.netID),Rep:100};bc.mu.RUnlock();data,_:=json.Marshal(nodeInfo);if bc.torDialer!=nil{for _,node:=range bc.Nodes{if conn,err:=bc.torDialer.Dial("udp",node.OnionAddr+":"+strconv.Itoa(port));err==nil{conn.Write(data);conn.Close()}}}else{conn,_:=net.Dial("udp","255.255.255.255:"+strconv.Itoa(port));conn.Write(data);conn.Close()};time.Sleep(30*time.Second)}}
func(bc*Blockchain)broadcastTx(tx*Tx){data,_:=json.Marshal(map[string]interface{}{"type":"tx","data":tx});bc.broadcast(data)}
func(bc*Blockchain)broadcastBlock(b*Block){data,_:=json.Marshal(map[string]interface{}{"type":"block","data":b});bc.broadcast(data)}
func(bc*Blockchain)broadcast(data[]byte){if bc.torDialer!=nil{for _,node:=range bc.Nodes{port:=P2PMainPort;if bc.netID==TestNetID{port=P2PTestPort};if conn,err:=bc.torDialer.Dial("tcp",node.OnionAddr+":"+strconv.Itoa(port));err==nil{conn.Write(data);conn.Close()}}}}
func(bc*Blockchain)syncChain(){for{bc.mu.RLock();maxHeight:=uint64(len(bc.Chain));bestNodes:=[]*P2PNode{};for _,node:=range bc.Nodes{if node.Height>maxHeight&&node.Rep>75{bestNodes=append(bestNodes,node)}};bc.mu.RUnlock();if len(bestNodes)>0{};time.Sleep(10*time.Second)}}
func(rpc*RPC)security(next http.Handler)http.Handler{return http.HandlerFunc(func(w http.ResponseWriter,r*http.Request){if strings.Contains(r.Header.Get("User-Agent"),"bot")||len(r.Header.Get("X-Forwarded-For"))>0{http.Error(w,"Forbidden",403);return};next.ServeHTTP(w,r)})}
func(rpc*RPC)rateLimit(next http.Handler)http.Handler{clients:=make(map[string]time.Time);return http.HandlerFunc(func(w http.ResponseWriter,r*http.Request){ip:=strings.Split(r.RemoteAddr,":")[0];if last,ok:=clients[ip];ok&&time.Since(last)<100*time.Millisecond{http.Error(w,"Rate Limited",429);return};clients[ip]=time.Now();next.ServeHTTP(w,r)})}
func(rpc*RPC)handleBalance(w http.ResponseWriter,r*http.Request){addr:=common.HexToAddress(r.URL.Query().Get("address"));token:=r.URL.Query().Get("token");rpc.bc.mu.RLock();acc:=rpc.bc.Accounts[addr];rpc.bc.mu.RUnlock();bal:="0";if acc!=nil{if token==""{bal=acc.Bal.String()}else{if tokenBal,ok:=acc.Tokens[common.HexToAddress(token)];ok{bal=tokenBal.String()}}};json.NewEncoder(w).Encode(map[string]string{"balance":bal})}
func(rpc*RPC)handleSendTx(w http.ResponseWriter,r*http.Request){var tx Tx;json.NewDecoder(r.Body).Decode(&tx);if err:=rpc.bc.AddTx(&tx);err!=nil{http.Error(w,err.Error(),400);return};json.NewEncoder(w).Encode(map[string]string{"status":"ok","hash":hex.EncodeToString(rpc.bc.txHash(&tx))})}
func(rpc*RPC)handleCreateToken(w http.ResponseWriter,r*http.Request){var req struct{Name,Symbol,MaxSupply,PrivKey string;Mintable bool};json.NewDecoder(r.Body).Decode(&req);privKey,_:=crypto.HexToECDSA(req.PrivKey);addr:=crypto.PubkeyToAddress(privKey.PublicKey);tokenData,_:=json.Marshal(map[string]interface{}{"name":req.Name,"symbol":req.Symbol,"maxSupply":req.MaxSupply,"mintable":req.Mintable});amt,_:=new(big.Int).SetString(strconv.Itoa(CoinCreateCost),10);tx:=&Tx{From:addr,To:common.HexToAddress("0x0000"),Value:amt,Type:"token_create",Data:tokenData,Nonce:rpc.bc.Accounts[addr].Nonce+1};hash:=rpc.bc.txHash(tx);sig,_:=crypto.Sign(hash,privKey);tx.Sig=sig;if err:=rpc.bc.AddTx(tx);err!=nil{http.Error(w,err.Error(),400);return};json.NewEncoder(w).Encode(map[string]string{"status":"created"})}
func(rpc*RPC)handleStake(w http.ResponseWriter,r*http.Request){var req struct{Address,Amount string};json.NewDecoder(r.Body).Decode(&req);addr:=common.HexToAddress(req.Address);amt,_:=new(big.Int).SetString(req.Amount,10);if err:=rpc.bc.Stake(addr,amt);err!=nil{http.Error(w,err.Error(),400);return};json.NewEncoder(w).Encode(map[string]string{"status":"staked"})}
func(rpc*RPC)handleCreateWallet(w http.ResponseWriter,r*http.Request){mnemonic:=generateMnemonic();wallet:=createWalletFromMnemonic(mnemonic);rpc.bc.mu.Lock();rpc.bc.Accounts[wallet.Addr]=&Account{Addr:wallet.Addr,Bal:big.NewInt(1000000000000000000),Stake:big.NewInt(0),Tokens:make(map[common.Address]*big.Int)};rpc.bc.mu.Unlock();wallet.Priv=wallet.encrypt(wallet.Priv);json.NewEncoder(w).Encode(wallet)}
func(rpc*RPC)handleRestoreWallet(w http.ResponseWriter,r*http.Request){var req struct{Mnemonic string};json.NewDecoder(r.Body).Decode(&req);wallet:=createWalletFromMnemonic(req.Mnemonic);wallet.Priv=wallet.encrypt(wallet.Priv);json.NewEncoder(w).Encode(wallet)}
func(rpc*RPC)handleOpenChannel(w http.ResponseWriter,r*http.Request){var req struct{Peer1,Peer2,Amount1,Amount2 string};json.NewDecoder(r.Body).Decode(&req);p1:=common.HexToAddress(req.Peer1);p2:=common.HexToAddress(req.Peer2);amt1,_:=new(big.Int).SetString(req.Amount1,10);amt2,_:=new(big.Int).SetString(req.Amount2,10);id:=rpc.bc.OpenLNChannel(p1,p2,amt1,amt2);json.NewEncoder(w).Encode(map[string]string{"channel_id":id})}
func(rpc*RPC)handleLNTransfer(w http.ResponseWriter,r*http.Request){var req struct{ChannelID,From,Amount string};json.NewDecoder(r.Body).Decode(&req);from:=common.HexToAddress(req.From);amt,_:=new(big.Int).SetString(req.Amount,10);if err:=rpc.bc.LNTransfer(req.ChannelID,from,amt);err!=nil{http.Error(w,err.Error(),400);return};json.NewEncoder(w).Encode(map[string]string{"status":"transferred"})}
func(rpc*RPC)handleCloseChannel(w http.ResponseWriter,r*http.Request){channelID:=r.URL.Query().Get("id");rpc.bc.CloseLNChannel(channelID);json.NewEncoder(w).Encode(map[string]string{"status":"closed"})}
func(rpc*RPC)handleBTCToETH(w http.ResponseWriter,r*http.Request){var req struct{BTCAddr,ETHAddr,Amount string};json.NewDecoder(r.Body).Decode(&req);ethAddr:=common.HexToAddress(req.ETHAddr);amt,_:=new(big.Int).SetString(req.Amount,10);amt.Mul(amt,big.NewInt(100000000));rpc.bc.mu.Lock();if acc,ok:=rpc.bc.Accounts[ethAddr];ok{acc.Bal.Add(acc.Bal,amt)}else{rpc.bc.Accounts[ethAddr]=&Account{Addr:ethAddr,Bal:amt,Stake:big.NewInt(0),Tokens:make(map[common.Address]*big.Int)}};rpc.bc.mu.Unlock();json.NewEncoder(w).Encode(map[string]string{"status":"converted"})}
func(rpc*RPC)handleInfo(w http.ResponseWriter,r*http.Request){rpc.bc.mu.RLock();info:=map[string]interface{}{"height":len(rpc.bc.Chain),"network_id":rpc.bc.netID,"validators":len(rpc.bc.Validators),"accounts":len(rpc.bc.Accounts),"channels":len(rpc.bc.Channels),"nodes":len(rpc.bc.Nodes),"tokens":len(rpc.bc.Tokens),"node_id":rpc.bc.nodeID,"onion_addr":rpc.bc.onionAddr,"tor_enabled":rpc.bc.torDialer!=nil};rpc.bc.mu.RUnlock();json.NewEncoder(w).Encode(info)}
func(rpc*RPC)handleTokens(w http.ResponseWriter,r*http.Request){rpc.bc.mu.RLock();tokens:=make(map[string]*Token);for addr,token:=range rpc.bc.Tokens{tokens[addr.Hex()]=token};rpc.bc.mu.RUnlock();json.NewEncoder(w).Encode(tokens)}
func cors(next http.Handler)http.Handler{return http.HandlerFunc(func(w http.ResponseWriter,r*http.Request){w.Header().Set("Access-Control-Allow-Origin","*");w.Header().Set("Access-Control-Allow-Methods","GET,POST,OPTIONS");w.Header().Set("Access-Control-Allow-Headers","Content-Type,Authorization");w.Header().Set("X-Content-Type-Options","nosniff");w.Header().Set("X-Frame-Options","DENY");w.Header().Set("X-XSS-Protection","1; mode=block");if r.Method=="OPTIONS"{w.WriteHeader(204);return};next.ServeHTTP(w,r)})}
func min(a,b int)int{if a<b{return a};return b}
func startNetwork(netID uint32,port int){bc:=NewBlockchain(netID);rpc:=&RPC{bc:bc};go func(){for{time.Sleep(time.Duration(BlockTime)*time.Second);bc.AddBlock()}}();go bc.discoverNodes();go bc.broadcastNode();go bc.syncChain();mux:=http.NewServeMux();routes:=map[string]http.HandlerFunc{"/balance":rpc.handleBalance,"/send":rpc.handleSendTx,"/stake":rpc.handleStake,"/wallet":rpc.handleCreateWallet,"/restore":rpc.handleRestoreWallet,"/channel/open":rpc.handleOpenChannel,"/channel/transfer":rpc.handleLNTransfer,"/channel/close":rpc.handleCloseChannel,"/btc2eth":rpc.handleBTCToETH,"/info":rpc.handleInfo,"/tokens":rpc.handleTokens,"/token/create":rpc.handleCreateToken};for path,handler:=range routes{mux.Handle(path,cors(rpc.security(rpc.rateLimit(http.HandlerFunc(handler)))))};netName:="MainNet";if netID==TestNetID{netName="TestNet"};fmt.Printf("WolfEther %s P2P Tor Blockchain + Lightning on :%d\n",netName,port);log.Fatal(http.ListenAndServe(":"+strconv.Itoa(port),mux))}
func main(){go startNetwork(MainNetID,MainPort);startNetwork(TestNetID,TestPort)}
RegisterExtraRPC()
